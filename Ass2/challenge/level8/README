For this program we find the error is that it does not correctly remove entries when an old entry is deleted and instead keeps them in the pair list. That means when a new entry that is smaller then the previous one is found it will overwrite that location even if it has beeen previously freed. To exploit this we first need to create a free portion just before a current entry . To do this we set up the stack by creating two a small space before a large allocation. We then have smaller spaces inside that allocation where we will deallocate the second space forcing it to allocate in an area which is not where it used to be. Now that that is achieved we can overwrite the free list with ```set(r, b"3", b"G"*62  + p64(ret_addr) + p64(0x405068))``` We want to overwrite the got address of exit at ```0x405068``` with the address of our shellcode. this happens when malloc tries to fix the free list and appends the our malicious next pointer to where the return address actually is. Our shellcode is on the heap instead of on the stack because making an environment variable with ssh pwntools is not something i could figure out and this was an easy alternative. After doing this i notice that i can successfully overwrite and reach my shellcode with the caveat that the shellcode is getting partly overwritten. Specifically we observed that the first 16 bytes are unchanged while the rest remains the same. This gives us a few choices rethink our approach or write shellcode that is less than 16 bytes that either executes a shell or jumps to something that executes a shell or an have an instruction that will "consume" the next 8 bytes that are overwritten such that the rest can be executed normally. We decide to just jump over it making the code 
```
shellcode_prev ="""
    mov rcx, 0x7fffffffe91effff
    shr rcx, 16
    jmp rcx
"""
```
This actual target is just 0x7fffffffe91e but since we cant insert nullbytes into strings we instead do an operation where we shift it to the right to add the nullbytes with a calculation. We then jump the the address of our actual shellcode which is nestled far away ```set(r, b"6", b"\xbb"*40 + shellcode_prev + b"\xff"*50 + shellcode + b"\xbb"*40)``` such that it does not get overwritten by the malloc implementation. we finally call exit so the overwritten got executes with our shellcode

run with python3 solve.py SSH